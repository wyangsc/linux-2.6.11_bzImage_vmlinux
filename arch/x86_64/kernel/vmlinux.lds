/* ld script to make x86-64 Linux kernel
 * Written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>;
 */
/*
 * Automatically generated C config: don't edit
 * Linux kernel version: 2.6.11
 * Fri Dec  8 10:44:58 2017
 */
/*
 * Code maturity level options
 */




/*
 * General setup
 */
/*
 * Loadable module support
 */
/*
 * Processor type and features
 */
/*
 * Power management options
 */





/*
 * ACPI (Advanced Configuration and Power Interface) Support
 */
/*
 * CPU Frequency scaling
 */
/*
 * CPUFreq processor drivers
 */





/*
 * shared options
 */



/*
 * Bus options (PCI etc.)
 */
/*
 * PCCARD (PCMCIA/CardBus) support
 */





/*
 * PC-card bridges
 */






/*
 * PCI Hotplug Support
 */


/*
 * Executable file formats / Emulations
 */
/*
 * Device Drivers
 */

/*
 * Generic Driver Options
 */





/*
 * Memory Technology Devices (MTD)
 */





/*
 * User Modules And Translation Layers
 */







/*
 * RAM/ROM/Flash chip drivers
 */
/*
 * Mapping drivers for chip access
 */


/*
 * Self-contained MTD device drivers
 */







/*
 * Disk-On-Chip Device Drivers
 */




/*
 * NAND Flash Device Drivers
 */


/*
 * Parallel port support
 */
/*
 * Plug and Play support
 */



/*
 * Protocols
 */


/*
 * Block devices
 */
/*
 * IO Schedulers
 */






/*
 * ATA/ATAPI/MFM/RLL support
 */


/*
 * SCSI device support
 */



/*
 * SCSI support type (disk, tape, CD-ROM)
 */







/*
 * Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 */




/*
 * SCSI Transport Attributes
 */




/*
 * SCSI low-level drivers
 */
/*
 * PCMCIA SCSI adapter support
 */




/*
 * Multi-device support (RAID and LVM)
 */
/*
 * Fusion MPT device support
 */





/*
 * IEEE 1394 (FireWire) support
 */


/*
 * I2O device support
 */


/*
 * Networking support
 */


/*
 * Networking options
 */
/*
 * IP: Virtual Server Configuration
 */




/*
 * IPVS transport protocol load balancing support
 */





/*
 * IPVS scheduler
 */
/*
 * IPVS application helper
 */






/*
 * IP: Netfilter Configuration
 */
/*
 * Bridge: Netfilter Configuration
 */
/*
 * SCTP Configuration (EXPERIMENTAL)
 */
/*
 * QoS and/or fair queueing
 */
/*
 * Network testing
 */





/*
 * Packet Radio protocols
 */





/*
 * AX.25 network device drivers
 */







/*
 * IrDA protocols
 */





/*
 * IrDA options
 */




/*
 * Infrared-port device drivers
 */

/*
 * SIR device drivers
 */


/*
 * Dongle support
 */
/*
 * Old SIR device drivers
 */

/*
 * Old Serial dongle support
 */

/*
 * FIR device drivers
 */







/*
 * Bluetooth device drivers
 */
/*
 * ARCnet devices
 */


/*
 * Ethernet (10 or 100Mbit)
 */



/*
 * Ethernet (1000 Mbit)
 */
/*
 * Ethernet (10000 Mbit)
 */






/*
 * Token Ring devices
 */


/*
 * Wireless LAN (non-hamradio)
 */


/*
 * PCMCIA network device support
 */


/*
 * Wan interfaces
 */
/*
 * ISDN subsystem
 */


/*
 * Old ISDN4Linux
 */
/*
 * ISDN feature submodules
 */


/*
 * ISDN4Linux hardware drivers
 */

/*
 * Passive cards
 */


/*
 * D-channel protocol features
 */
/*
 * HiSax supported cards
 */
/*
 * HiSax PCMCIA card service modules
 */





/*
 * HiSax sub driver modules
 */




/*
 * Active cards
 */


/*
 * CAPI subsystem
 */






/*
 * CAPI hardware drivers
 */

/*
 * Active AVM cards
 */
/*
 * Active Eicon DIVA Server cards
 */
/*
 * Telephony Support
 */


/*
 * Input device support
 */


/*
 * Userland interfaces
 */
/*
 * Input I/O drivers
 */
/*
 * Input Device Drivers
 */
/*
 * Character devices
 */
/*
 * Serial drivers
 */
/*
 * Non-8250 serial port support
 */
/*
 * IPMI
 */







/*
 * Watchdog Cards
 */



/*
 * Watchdog Device Drivers
 */
/*
 * PCI-based Watchdog Cards
 */




/*
 * USB-based Watchdog Cards
 */
/*
 * Ftape, the floppy tape device driver
 */
/*
 * PCMCIA character devices
 */
/*
 * I2C support
 */



/*
 * I2C Algorithms
 */




/*
 * I2C Hardware Bus support
 */
/*
 * Hardware Sensors Chip support
 */
/*
 * Other I2C Chip support
 */
/*
 * Dallas's 1-wire bus
 */






/*
 * Misc devices
 */


/*
 * Multimedia devices
 */


/*
 * Video For Linux
 */

/*
 * Video Adapters
 */
/*
 * Radio Adapters
 */




/*
 * Digital Video Broadcasting Devices
 */
/*
 * Graphics support
 */
/*
 * Console display driver support
 */







/*
 * Logo configuration
 */
/*
 * Sound
 */


/*
 * Advanced Linux Sound Architecture
 */
/*
 * Generic devices
 */
/*
 * PCI devices
 */
/*
 * USB devices
 */



/*
 * PCMCIA devices
 */

/*
 * Open Sound System
 */


/*
 * USB support
 */



/*
 * Miscellaneous USB options
 */
/*
 * USB Host Controller Drivers
 */







/*
 * USB Device Class drivers
 */


/*
 * USB Bluetooth TTY can only be used with disabled Bluetooth subsystem
 */




/*
 * NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
 */
/*
 * USB Input Devices
 */
/*
 * USB Imaging devices
 */



/*
 * USB Multimedia devices
 */
/*
 * USB Network Adapters
 */






/*
 * USB Host-to-Host Cables
 */
/*
 * Intelligent USB Devices/Gadgets
 */





/*
 * USB Network Adapters
 */

/*
 * USB port drivers
 */


/*
 * USB Serial Converter support
 */
/*
 * USB Miscellaneous drivers
 */
/*
 * USB ATM/DSL drivers
 */

/*
 * USB Gadget Support
 */


/*
 * MMC/SD Card support
 */




/*
 * InfiniBand support
 */







/*
 * Firmware Drivers
 */


/*
 * File systems
 */
/*
 * XFS support
 */
/*
 * CD-ROM/DVD Filesystems
 */







/*
 * DOS/FAT/NT Filesystems
 */







/*
 * Pseudo filesystems
 */
/*
 * Miscellaneous filesystems
 */
/*
 * Network File Systems
 */
/*
 * Partition Types
 */
/*
 * Native Language Support
 */
/*
 * Profiling support
 */



/*
 * Kernel hacking
 */
/*
 * Security options
 */
/*
 * Cryptographic options
 */
/*
 * Hardware crypto devices
 */

/*
 * Library routines
 */
OUTPUT_FORMAT("elf64-x86-64", "elf64-x86-64", "elf64-x86-64")
OUTPUT_ARCH(i386:x86-64)
ENTRY(_start)
jiffies_64 = jiffies;
SECTIONS
{
  . = 0xffffffff80100000;
  _text = .; /* Text and read-only data */
  .text : {
        *(.text)
        __sched_text_start = .; *(.sched.text) __sched_text_end = .;
        __lock_text_start = .; *(.spinlock.text) __lock_text_end = .;
        *(.fixup)
        *(.gnu.warning)
        } = 0x9090
  .text.lock : { *(.text.lock) } /* out-of-line lock text */

  _etext = .; /* End of text section */

  . = ALIGN(16); /* Exception table */
  __start___ex_table = .;
  __ex_table : { *(__ex_table) }
  __stop___ex_table = .;

  .rodata : AT(ADDR(.rodata) - 0) { *(.rodata) *(.rodata.*) *(__vermagic) } .rodata1 : AT(ADDR(.rodata1) - 0) { *(.rodata1) } .pci_fixup : AT(ADDR(.pci_fixup) - 0) { __start_pci_fixups_early = .; *(.pci_fixup_early) __end_pci_fixups_early = .; __start_pci_fixups_header = .; *(.pci_fixup_header) __end_pci_fixups_header = .; __start_pci_fixups_final = .; *(.pci_fixup_final) __end_pci_fixups_final = .; __start_pci_fixups_enable = .; *(.pci_fixup_enable) __end_pci_fixups_enable = .; } __ksymtab : AT(ADDR(__ksymtab) - 0) { __start___ksymtab = .; *(__ksymtab) __stop___ksymtab = .; } __ksymtab_gpl : AT(ADDR(__ksymtab_gpl) - 0) { __start___ksymtab_gpl = .; *(__ksymtab_gpl) __stop___ksymtab_gpl = .; } __kcrctab : AT(ADDR(__kcrctab) - 0) { __start___kcrctab = .; *(__kcrctab) __stop___kcrctab = .; } __kcrctab_gpl : AT(ADDR(__kcrctab_gpl) - 0) { __start___kcrctab_gpl = .; *(__kcrctab_gpl) __stop___kcrctab_gpl = .; } __ksymtab_strings : AT(ADDR(__ksymtab_strings) - 0) { *(__ksymtab_strings) } __param : AT(ADDR(__param) - 0) { __start___param = .; *(__param) __stop___param = .; }

  .data : { /* Data */
        *(.data)
        CONSTRUCTORS
        }

  _edata = .; /* End of data section */

  __bss_start = .; /* BSS */
  .bss : {
        *(.bss.page_aligned)
        *(.bss)
        }
  __bss_end = .;

  . = ALIGN(128);
  .data.cacheline_aligned : { *(.data.cacheline_aligned) }





  .vsyscall_0 -10*1024*1024: AT ((LOADADDR(.data.cacheline_aligned) + SIZEOF(.data.cacheline_aligned) + 4095) & ~(4095)) { *(.vsyscall_0) }
  __vsyscall_0 = LOADADDR(.vsyscall_0);
  . = ALIGN(128);
  .xtime_lock : AT ((((((LOADADDR(.vsyscall_0) + SIZEOF(.vsyscall_0)) + (16) - 1) & ~((16) - 1))) + (128) - 1) & ~((128) - 1)) { *(.xtime_lock) }
  xtime_lock = LOADADDR(.xtime_lock);
  .vxtime : AT (((LOADADDR(.xtime_lock) + SIZEOF(.xtime_lock)) + (16) - 1) & ~((16) - 1)) { *(.vxtime) }
  vxtime = LOADADDR(.vxtime);
  .wall_jiffies : AT (((LOADADDR(.vxtime) + SIZEOF(.vxtime)) + (16) - 1) & ~((16) - 1)) { *(.wall_jiffies) }
  wall_jiffies = LOADADDR(.wall_jiffies);
  .sys_tz : AT (((LOADADDR(.wall_jiffies) + SIZEOF(.wall_jiffies)) + (16) - 1) & ~((16) - 1)) { *(.sys_tz) }
  sys_tz = LOADADDR(.sys_tz);
  .sysctl_vsyscall : AT (((LOADADDR(.sys_tz) + SIZEOF(.sys_tz)) + (16) - 1) & ~((16) - 1)) { *(.sysctl_vsyscall) }
  sysctl_vsyscall = LOADADDR(.sysctl_vsyscall);
  .xtime : AT (((LOADADDR(.sysctl_vsyscall) + SIZEOF(.sysctl_vsyscall)) + (16) - 1) & ~((16) - 1)) { *(.xtime) }
  xtime = LOADADDR(.xtime);
  . = ALIGN(128);
  .jiffies : AT ((((((LOADADDR(.xtime) + SIZEOF(.xtime)) + (16) - 1) & ~((16) - 1))) + (128) - 1) & ~((128) - 1)) { *(.jiffies) }
  jiffies = LOADADDR(.jiffies);
  .vsyscall_1 ADDR(.vsyscall_0) + 1024: AT (LOADADDR(.vsyscall_0) + 1024) { *(.vsyscall_1) }
  . = LOADADDR(.vsyscall_0) + 4096;

  . = ALIGN(8192); /* init_task */
  .data.init_task : { *(.data.init_task) }

  . = ALIGN(4096);
  .data.page_aligned : { *(.data.page_aligned) }

  . = ALIGN(4096); /* Init code and data */
  __init_begin = .;
  .init.text : {
        _sinittext = .;
        *(.init.text)
        _einittext = .;
  }
  __initdata_begin = .;
  .init.data : { *(.init.data) }
  __initdata_end = .;
  . = ALIGN(16);
  __setup_start = .;
  .init.setup : { *(.init.setup) }
  __setup_end = .;
  __initcall_start = .;
  .initcall.init : {
        *(.initcall1.init)
        *(.initcall2.init)
        *(.initcall3.init)
        *(.initcall4.init)
        *(.initcall5.init)
        *(.initcall6.init)
        *(.initcall7.init)
  }
  __initcall_end = .;
  __con_initcall_start = .;
  .con_initcall.init : { *(.con_initcall.init) }
  __con_initcall_end = .;
  .security_initcall.init : { __security_initcall_start = .; *(.security_initcall.init) __security_initcall_end = .; }
  . = ALIGN(8);
  __alt_instructions = .;
  .altinstructions : { *(.altinstructions) }
  __alt_instructions_end = .;
 .altinstr_replacement : { *(.altinstr_replacement) }
  /* .exit.text is discard at runtime, not link time, to deal with references
     from .altinstructions and .eh_frame */
  .exit.text : { *(.exit.text) }
  .exit.data : { *(.exit.data) }
  . = ALIGN(4096);
  __initramfs_start = .;
  .init.ramfs : { *(.init.ramfs) }
  __initramfs_end = .;
  . = ALIGN(32);
  __per_cpu_start = .;
  .data.percpu : { *(.data.percpu) }
  __per_cpu_end = .;
  . = ALIGN(4096);
  __init_end = .;

  . = ALIGN(4096);
  __nosave_begin = .;
  .data_nosave : { *(.data.nosave) }
  . = ALIGN(4096);
  __nosave_end = .;

  _end = . ;

  /* Sections to be discarded */
  /DISCARD/ : {
        *(.exitcall.exit)



        }

  /* DWARF 2 */
  .debug_info 0 : { *(.debug_info) }
  .debug_abbrev 0 : { *(.debug_abbrev) }
  .debug_line 0 : { *(.debug_line) }
  .debug_frame 0 : { *(.debug_frame) }
  .debug_str 0 : { *(.debug_str) }
  .debug_loc 0 : { *(.debug_loc) }
  .debug_macinfo 0 : { *(.debug_macinfo) }
  /* SGI/MIPS DWARF 2 extensions */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames 0 : { *(.debug_varnames) }


  .comment 0 : { *(.comment) }
}
